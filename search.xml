<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 SSH 实现远程登录和内网穿透]]></title>
    <url>%2F2019%2F02%2F18%2F%E4%BD%BF%E7%94%A8SSH%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%92%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[前言在开发过程当中经常会碰到这样的需求，通过某一台外网的跳板机器登录到另一台的内网机器上，或者需要直接访问内网机器上的资源, 比如传输文件、访问 web 资源等。 其实像这种需求有很多种方式可以实现，比如 nginx 反向代理、shadowsocks 代理、iptables 端口转发等等，在这里主要介绍使用 SSH 的端口转发实现。对于服务端的开发人员来说 SSH 简直是神器之一。 SSH 实现端口转发SSH 共提供了三种端口转发，分别是本地转发、远程转发、动态转发。 本地转发（用-L参数）将访问本地主机端口的请求转发到远程主机的端口上，命令形式如下: 1ssh -NL [本地主机]:[本地端口]:[远程主机]:[远程端口] [用户名]@[跳板机] 这里的 -N 参数是指，只建立隧道，不执行远程机器的任何命令，如果没有 -N 话同时还会默认登录到主机，或者执行指定命令。 场景1 前提是主机A有权限访问 http://10.0.0.2:8888，且终端X有权限登录主机A（10.0.0.1）。 这种情况执行以下命令，把终端X的 9999 端口请求通过主机A转发到远程主机B（10.0.0.2）的 8888 端口上，所以，在终端X的浏览器中直接访问 http://127.0.0.1:9999 即可。 1234ssh -NL 0.0.0.0:9999:10.0.0.2:8888 user_a@10.0.0.1# 本地主机可以省略ssh -NL 9999:10.0.0.2:8888 user_a@10.0.0.1 场景2 虽然终端X可以直接登录主机B，但可能由于防火墙、内网服务等因素无法直接访问 http://10.0.1.2:8888 的服务。 这种情况执行以下命令，把终端X的 9999 端口请求转发到远程主机B（10.0.1.2）的 8888 端口上即可，注意这里主机B上有两个网段的 IP 地址，可能是一个外网，一个内网。 1234ssh -NL 0.0.0.0:9999:10.0.1.2:8888 user_b@10.0.0.2# 本地主机可以省略ssh -NL 9999:10.0.1.2:8888 user_b@10.0.0.2 以上两种场景都是终端X把本地主机的请求转发到远程主机，所以称为本地转发。 远程转发（用-R参数）将远程主机端口的请求本地主机转发到内网中的服务端口上，命令形式如下: 1ssh -NR [远程主机监听地址]:[远程主机监听端口]:[内网主机]:[内网端口] [用户名]@[远程主机] 场景1 这里终端X是无法直接访问主机A的 http://10.0.1.1:8888 服务的，也不能访问主机B，只能访问主机C。 主机B是可以登录主机C的，而且主机B能访问主机A的 http://10.0.1.1:8888 服务。 主机C也是无法直接访问主机B和主机A的。 这种情况就需要在主机B上配置 SSH 的端口转发，将对主机C的 9999 端口的请求转发到主机A的 8888 端口上。 在这里主机B的功能都是把远程主机端口的请求转发到内网中，所以这种情况称为远程转发。 这里要实现远程转发需要主机C的 sshd_config 开启了 AllowTcpForwarding 选项，否则远程转发会失败。 远程主机上的端口绑定的是127.0.0.1，如要绑定0.0.0.0的网段，主机C的 sshd_config 需要开启 GatewayPorts 选项。或者在主机C上再用一次本地转发到0.0.0.0网段也是可以的。 动态转发（用-D参数）动态转发其实就是 socks5 代理，跟远程主机建立一条隧道，并在本地监听一个端口，所有经过这个端口的请求都统一发到远程主机上由远程主机代理发起请求。所以这样就可以访问代理主机能访问的而且本身直接访问不了的所有服务, 那样就不需要一个端口一个端口去转发了，而且安全性更高。命令格式如下: 1ssh -ND [本地主机监听地址]:[本地主机监听端口] [用户名]@[远程主机] 场景1 这里终端X只能登录主机A，其它的主机B ~ D 都无法访问。 这个时候如果配置一条动态转发，只要在主机A中能访问的服务，在终端X就能访问，不管是内网还是外网。 1ssh -ND user_a@10.0.0.1 这种方式如果终端A需要访问主机B ~ D的话，就需要配置走 socks5 的代理方式，比如浏览器访问网页、SSH远程登录等等。 因为这种转发完全不需要考虑具体的要访问的服务，只要能访问的都自动转发，所以称为动态转发。 通过跳板机直接登录内网主机最简单粗暴的方式就是先从终端X登录到主机A，再从主机A登录到主机B，这样的话就非常烦琐，想访问主机B还需要两次登录操作，如果后面还有主机C、主机D，那就需要更多次登录操作了，其实 SSH 提供了更简单的方式可以做到。其实你会发现，只要了解了上面几种端口转发方式，无论是跳板机登录、拷贝文件、或者访问 web 服务，都轻而易举了。 使用 -J 参数的方式 1234ssh -At user_b@10.0.0.2 -J user_a@10.0.0.1# 中间有多台跳板机器ssh -At user_c@10.0.0.3 -J user_a@10.0.0.1,user_b@10.0.0.2 使用 ProxyCommand 的方式 1ssh -At user_b@10.0.0.2 -o ProxyCommand="ssh user_a@10.0.0.1 -W %h:%p" 端口转发的方式 12345# 先配置动态转发ssh -ND localhost:8888 user_a@10.0.0.1# 登录主机ssh -At -o ProxyCommand='/usr/bin/nc -X 5 -x localhost:8888 %h %p' user_b@10.0.0.2 ~/.ssh/config 配置文件的方式 使用 scp 或 rsync 命令穿透跳板机器进行文件同步 使用 ProxyCommand 的方式 12345# scpscp -o "ProxyCommand ssh user_a@10.0.0.1 -W %h:%p" user_b@10.0.0.2:/path/to/file ./out/# rsyncrsync -e "ssh -o 'ProxyCommand ssh user_a@10.0.0.1 -W %h:%p'" user_b@10.0.0.2:/path/to/file ./out/ 其中 10.0.0.1 是跳板主机，10.0.0.2 是内网机器。 端口转发的方式 12345678# 先配置动态转发ssh -ND localhost:8888 user_a@10.0.0.1# scpscp -o "ProxyCommand /usr/bin/nc -X 5 -x localhost:8888 %h %p" user_b@10.0.0.2:/path/to/file ./out/# rsyncrsync -e "ssh -o 'ProxyCommand /usr/bin/nc -X 5 -x localhost:8888 %h %p'" user_b@10.0.0.2:/path/to/file ./out/]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>内网穿透</tag>
        <tag>rsync</tag>
        <tag>scp</tag>
        <tag>socks5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 发送 POST 请求之 Multipart/form-data]]></title>
    <url>%2F2019%2F02%2F14%2FPython%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82%E4%B9%8Bmultipart_form-data%2F</url>
    <content type="text"><![CDATA[前言在 HTTP/1.1 协议中，使用 POST 请求提交数据时常用的 Content-Type 有以下几种: application/x-www-form-urlencoded 原生 Form 默认的提交方式, 最常用的一种，支持GET/POST等方法。主要把数据编码成键值对的方式, 并且把特殊字符转义成 utf-8 字符，如空格会被转义成 %20。 application/json 由于 JSON 格式所表示的结构化数据远比键值对复杂得多，所以使用 JSON 系列化之后的字符串进行数据交换的方式越来越受人们青睐。特别适合 RESTful 类型的接口。 text/xml 使用 XML-RPC(XML Remote Procedure Call) 协议进行数据传输，相比于 JSON 的方式更为臃肿。 multipart/form-data 使用 Form 提交小文件, 直接把文件内容放在 Body 中进行传输的方式。考虑到同时上传多个字段或文件，所以需要按照一定规则随机生成或手动指定一个 boundary 用于分割数据，然后按照一定格式、顺序进行排列构成完整的 Body 进行传输。(multipart/form-data 官方定义) 客户端发送 multipart/form-data 请求假设现在有 ./file_1.txt 和 ./file_2.txt 两个文件，内容分别如下: 12345# cat ./file_1.txttest file 1 content!# cat ./file_2.txttest file 2 content! 使用 Requests 实现1234567891011import requestsdata = &#123;'key_1': 'value_1', 'key_2': 'value_2'&#125;files = [ ('file_1', open('./file_1.txt', 'rb')), ('file_2', open('./file_2.txt', 'rb')),]resp = requests.post('http://127.0.0.1:8000/upload', data=data, files=files)print(resp.request.body.decode('utf-8')) 打印出来的 request body 内容是这样的 12345678910111213141516171819--bfa60c05b6631915da313e8fb696e7b2Content-Disposition: form-data; name="key_1"value_1--bfa60c05b6631915da313e8fb696e7b2Content-Disposition: form-data; name="key_2"value_2--bfa60c05b6631915da313e8fb696e7b2Content-Disposition: form-data; name="file_1"; filename="file_1.txt"test file 1 content!--bfa60c05b6631915da313e8fb696e7b2Content-Disposition: form-data; name="file_2"; filename="file_2.txt"test file 2 content!--bfa60c05b6631915da313e8fb696e7b2-- 其中 bfa60c05b6631915da313e8fb696e7b2 就是上面所提到自动生成的 boundary。 值得注意的是 {&#39;key_1&#39;: &#39;value_1&#39;, &#39;key_2&#39;: &#39;value_2&#39;} 这两个本身是键值对的数据也被自动转成了 multipart/form-data 的编码方式。如果不传 files 字段时，将自动使用 application/x-www-form-urlencoded 的编码方式，所以 request body 内容应该是这样的 1key_1=value_1&amp;key_2=value_2 在 requests 中数据编码时，只有 data 参数为 None 时才会判断使用 json 参数，所以 data 和 json 两个参数同时存在时，只会编码 data 的数据；但 data 和 files 是可以同时存在的，而且只要有 files 存在，其它键值对数据也会一起使用 multipart/form-data 的编码方式生成 body 数据。 12345# json 参数将会被忽略resp = requests.post('http://127.0.0.1:8000/upload', data=data, json=xxxx)# 这样是 OK 的resp = requests.post('http://127.0.0.1:8000/upload', data=data, files=files) 使用 AIOHTTP 实现1234567891011121314151617import asyncioimport aiohttpasync def send_request(): async with aiohttp.ClientSession() as session: data = aiohttp.FormData() data.add_field('key_1', 'value_1') data.add_field('key_2', 'value_2') data.add_field('file_1', open('./file_1.txt', 'rb'), filename='file_1.txt', content_type='multipart/form-data') data.add_field('file_2', open('./file_2.txt', 'rb'), filename='file_2.txt', content_type='multipart/form-data') async with session.post('http://127.0.0.1:8000/upload', data=data) as resp: print(await resp.text())asyncio.run(send_request()) 打印出来的 request body 如下 123456789101112131415161718192021222324252627--a63b12cbef044b039c5c788b25a71336Content-Type: text/plain; charset=utf-8Content-Disposition: form-data; name=&quot;key_1&quot;Content-Length: 7value_1--a63b12cbef044b039c5c788b25a71336Content-Type: text/plain; charset=utf-8Content-Disposition: form-data; name=&quot;key_2&quot;Content-Length: 7value_2--a63b12cbef044b039c5c788b25a71336Content-Type: multipart/form-dataContent-Disposition: form-data; name=&quot;file_1&quot;; filename=&quot;file_1.txt&quot;; filename*=utf-8&apos;&apos;file_1.txtContent-Length: 21test file 1 content!--a63b12cbef044b039c5c788b25a71336Content-Type: multipart/form-dataContent-Disposition: form-data; name=&quot;file_2&quot;; filename=&quot;file_2.txt&quot;; filename*=utf-8&apos;&apos;file_2.txtContent-Length: 21test file 2 content!--a63b12cbef044b039c5c788b25a71336-- 可以看到 aiohttp 对键值对默认使用了 Content-Type: text/plain, 即纯文本的方式，这只是不同库的默认值和实现方式有些区别而已。 服务端解析 multipart/form-data 请求这里服务端使用 Sanic 框架接收数据请求，Sanic 是 python3 中性能非常好异步无阻塞的 web 框架，特别是跟 uvloop 配合着使用，性能上可以发挥到极致。用法跟Flask非常类似。项目主页: https://github.com/huge-success/sanic。 123456789101112from sanic import Sanic, responseapp = Sanic(__name__)@app.post('/upload')async def upload_handler(request): print('request.files', request.files) print('request.form', request.form) return response.text('ok')if __name__ == "__main__": app.run(host='0.0.0.0', port=8000) 输出信息如下 12request.files &#123;&apos;file_1&apos;: [File(type=&apos;multipart/form-data&apos;, body=b&apos;test file 1 content!\n&apos;, name=&apos;file_1.txt&apos;)], &apos;file_2&apos;: [File(type=&apos;multipart/form-data&apos;, body=b&apos;test file 2 content!\n&apos;, name=&apos;file_2.txt&apos;)]&#125;request.form &#123;&apos;key_1&apos;: [&apos;value_1&apos;], &apos;key_2&apos;: [&apos;value_2&apos;]&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>POST</tag>
        <tag>Multipart/form-data</tag>
      </tags>
  </entry>
</search>
